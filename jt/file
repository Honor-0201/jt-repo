反向代理： 当用户发起请求时根据规则拦截用户的请求之后，代替用户访问真实资源的过程称之为反向代理
Nginx 官方定义5w/s 实际3w/s

Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件(IMAP/POP3)代理服务器， 在BSD-like
协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力在
同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。
命令启动：start nginx 重启： nginx -s reload 关闭 nginx -s stop 

Tomcat并发压力：官方定义220/s实际150/s



负载均衡之后 导致每次用户访问的服务器都不一样，但是session无法共享 用户信息无法共享 可是使用 iphash来解决
可以保证同一个用户访问的一定是同一台tomcat 将用户ip与tomcat绑定
但是用户的ip是会变化的，都是拨号上网，ip2-3天换一次，换的话就需要重新登录. 如果后台服务器宕机咋会影响一部分用户不可以正常访问.
还会导致用户负载不均 所以工作中不会常使用iphash，测试操作时可能会用到 实际开发中使用sso实现用户数据的共享 常用属性：
down属性：如果后台服务器宕机，则可以使用down属性标识，Nginx负载均衡是不会再访问该服务器 backup属性：标识为
备用机，正常情况下用户不会访问备用机，当主机宕机或者主机遇忙的时候访问
 服务器上线步骤 
 1.将项目打包部署jar/war 
 2.根据服务器数量设计上线计划 
 3.先将部署的服务器在nginx中down 
 4.之后讲项目部署测试
 5.将down属性去掉 部署其他的服务器
在nginx重启的时候 用户访问如何解决 一般不做处理 原因：一般用户请求访问服务器的时候都会有超时时间 3-5s
nginx的启动时间不足1s，启动之后继续为用户提供服务 一般都在半夜或者下班时候部署，看具体行业
游戏的部署无法按照上述规则 提前通知上线计划，停服更新
nginx实现 Tomcat高可用 当服务器发生故障的时候，能够自动的实现故障的迁移 实现说明：
在Tomcat服务器之后标识2个属性，一个是失败的次数，一个是延时的时间 如果用户访问服务器，当访问的次数达到了最大的次数，则在一个延时周期内
不会再次请求该服务器，直到下一个周期

Redis 实现缓存需要考虑的问题 
1.存储结构 K-V key不可重复 
2.开发语言 C 执行的快 
3.缓存数据都保存在内存中 用户可以快速读取断电即擦除 
4.将内存中的数据定期持久化到本地磁盘中 
5.定期对内存数据优化 
LRU算法：可以将内存中不经常使用的数据提前删除


LFU算法：可以将内存中使用次数最少的数据提前删除
	   
Redis缓存 
Redis 是一个开源(BSD许可)的,内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 
它支持多种类型的数据结构，如字符串(strings), 散列(hashes), 列表(lists), 集合(sets), 有序集合(sorted sets)与范围查询，
bitmaps， hyperloglogs 和 地理空间(geospatial) 索引半径查询。 

Redis 内置了复制(replication),LUA脚本(Lua scripting), LRU驱动事件(LRU eviction), 事务(transactions)
和不同级别的 磁盘持久化(persistence), 并通过 Redis哨兵(Sentinel)和自动 分区(Cluster)提供高可用性(high availability)。
	   
Redis性能：
读：11.2w/s 写：8.6w/s 平均吞吐量：10w/s 
make:编译文件 make install:安装服务
 启动redis  redis-server redis.conf  默认 端口：6379  
	  
1.去掉ip绑定
2.关闭保护模式
3.开启后台启动
进入redis客户端
redis-cli -p 6379



@JsonIgnoreProperties(ignoreUnknown=true)
当程序转换时候遇到未知数属性自动忽略


切面 = 切入点 + 通知
切入点种类
1.com.xxx.xxx.类名  按类匹配
2.within(包名.类名)  按类匹配
3.execution(返回值类型 包名.类名(参数列表))  最常用
4.@annotation(包名.注解名称)  注解形式  其次
通知的种类
1.环绕通知  功能最为强大  控制目标方法是否执行0
2.前置通知   目标方法执行之前通知
3.后置通知   目标方法执行之后通知
4.异常通知   当目标方法抛出异常时通知
5.最终通知   无论何时都会执行的通知

hash一致性规则
node节点通过 hasp(IP)+算法

均衡性
 为了解决数据分配不均衡，采用虚拟节点的方式实现数据的均衡
 -如果没有虚拟节点平衡数据，则会导致数据分布不均

单调性
当节点新增时，实现数据的自动迁移
一旦节点宕机则内存缺失，整个的分片不能正常使用

分散性
  由于分布式的部署导致某些服务器不能使用全部的内存空间，同一个key原来只有一个位置，导致会有多个位置
  
负载
 由于分布式的部署导致某些服务器不能使用全部的内存空间，同一个位置可能会有多个key

如何防止： 
 尽可能使用全部的内存空间，能够有效的降低分散性和负载
 
 redis的持久化方式
  redis会根据配置文件的规则，定期将内存中的数据持久化到磁盘中
  
  RDB模式 redis是默认的持久化策略
   特点：
     1.定期实现数据的持久化，可能会丢失数据
     2.记录的是内存数据的快照，持久化文件小（rdb文件比较小）-覆盖操作
     3.RDB进行持久化操作时时阻塞的
     4.一般使用持久化策略RDB效率是最高的，建议使用
     
RDB配置
save指令：可以通过客户端执行save指令，实现内存数据的持久化策略  表示现在立即执行，同步操作，会造成线程阻塞
bgsave：后台运行，异步操作

RDB持久化策略
save 900 1     如果用户在900s内，执行1次更新操作时，则持久化一次
save 300 10    如果用户在300s内，执行10次更新操作时，则持久化一次
save 60 10000  如果用户在60s内，执行10000次更新操作时，则持久化一次
save 1 1 效率极低

RDB持久化名称的配置 可以修改持久化文件名称

AOF模式
  默认是关闭的，如果使用需要开启，AOF模式做的事数据的追加，所以持久化的文件较大
  特点：
  1.默认关闭
  2.持久化时记录用户操作的过程，之后追加到持久化文化中
  3.可以实现数据的实时备份，保证数据安全
  4.效率要低于RDB模式
  5.持久化的文件需要定期维护
  6.是异步的，不会阻塞
  
AOF持久化策略
appendfsync always     用户每操作一次，持久化一次
appendfsync everysec   每秒持久化一次
appendfsync no         由操作系统决定何时持久化


redis内存策略
 redis中自己有内存优化策略，能够保证在内存数据即将达到上限时，能够实现自动的优化，但是该策略默认是关闭的 
 
内存优化的策略
 
  

  
 























